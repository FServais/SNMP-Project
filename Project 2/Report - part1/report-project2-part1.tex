\documentclass[a4paper,titlepage]{article}

%PACKAGES
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{fancyhdr}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancybox}
\usepackage{textcomp}

%Symbole euro
\usepackage{eurosym}

%Listings : affichage code
\usepackage{listings}


%Elements de la page de garde
\begin{document}

\begin{titlepage}

\begin{figure}
\centering
\includegraphics[width=5cm]{logo-ulg.png}
\end{figure}



\title{
\vspace{0.2cm}
\LARGE{\textbf{Project 2 - Developing a web-based SNMP browser : Detecting the SNMP Agents}} \\ \textsc{Managing and securing computer networks}
\author{\textbf{Floriane Magera} \small{(S111295})\\\textbf{Fabrice Servais} \small{(S111093})}\\
\date{March 10, 2015}
\rule{15cm}{1.5pt}
}

%\geometry{hmargin=2.5cm}
\end{titlepage}

%DOCUMENT
\pagestyle{fancy}
\lhead{Project 2 - Developing a web-based SNMP browser : Detecting the SNMP Agents}
\rhead{Managing and securing computer networks}

%Page de garde
\maketitle


\section{Introduction}




\section{Parsing}





\section{Detecting the agents}
First we generated a list of all the targets possible : for each ip adress in the domain, we consider all the credentials possible.  Then depending on the snmp version of the target, we use different methods to send the request aiming the agent. 
	
	\subsection{SNMPv1 and SNMPv2}
	We used the library pysnmp to send asynchronous requests to all the agents in the domain. Instead of using a snmpget request, we use a getnext 
	request. The agent returns the next object in its tree if the object requested is not available. Every target has an entry in a hashtable. When 	the request is completed, if we receive  an error, the entry corresponding to the target is deleted. At the end of the process, the hashtable 		contains only the agents present in the network. 




	\subsection{SNMPv3}
	As the asynchronous requests did not work with the library we use, we decided to launch treads and use the synchronous requests of the library. 
	For that we use a pool of 15 threads.  We used the same request as in the previous case. We tried to use a suitable number of threads to make  	    the detection as fast as possible and to avoid overloading the machine or the network.



\section{Results}
We write all the informations about the agents in a XML file.

\end{document}
